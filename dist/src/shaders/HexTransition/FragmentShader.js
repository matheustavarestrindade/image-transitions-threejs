import { createDebugGLSLCode } from "../debug/DigitsToConsoleDebug";
import { FromShaderToy } from "../FromShaderToy";
export var loadFragmentShader = function (debugMode) {
    return FromShaderToy("\n    #define HEXTILE_SIZE 0.125\n    #define RANDOMNESS   0.75\n    #define PERIOD       8.0\n\n    float hash(vec2 co) {\n        return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n    }\n\n    float tanh_approx(float x) {\n        float x2 = x*x;\n        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n    }\n\n    vec3 hsv2rgb(vec3 c) {\n        const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n\n    float hex(vec2 p, float r) {\n        p.xy = p.yx;\n        const vec3 k = vec3(-sqrt(3.0/4.0),1.0/2.0,1.0/sqrt(3.0));\n        p = abs(p);\n        p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n        p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n        return length(p)*sign(p.y);\n    }\n\n    vec2 hextile(inout vec2 p) {\n        const vec2 sz       = vec2(1.0, sqrt(3.0));\n        const vec2 hsz      = 0.5*sz;\n\n        vec2 p1 = mod(p, sz)-hsz;\n        vec2 p2 = mod(p - hsz, sz)-hsz;\n        vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n        vec2 n = ((p3 - p + hsz)/sz);\n        p = p3;\n\n        n -= vec2(0.5);\n        return round(n*2.0)/2.0;\n    }\n\n    float pmin(float a, float b, float k) {\n        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n        return mix( b, a, h ) - k*h*(1.0-h);\n    }\n\n    float pmax(float a, float b, float k) {\n        return -pmin(-a, -b, k);\n    }\n\n    vec3 hexTransition(vec2 p, float aa, vec3 from, vec3 to, float m) {\n        m = clamp(m, 0.0, 1.0);\n        const float hz = HEXTILE_SIZE;\n        const float rz = RANDOMNESS;\n        vec2 hp = p;\n        hp /= hz;\n        vec2 hn = hextile(hp)*hz*-vec2(-1.0, sqrt(3.0));\n        float r = hash(hn+123.4);\n        \n        const float off = 3.0;\n        float fi = smoothstep(0.0, 0.1, m);\n        float fo = smoothstep(0.9, 1.0, m);\n\n        float sz = 0.45*(0.5+0.5*tanh_approx(((rz*r+hn.x + hn.y-off+m*off*2.0))*2.0));\n        float hd = (hex(hp, sz)-0.1*sz)*hz;\n        \n        float mm = smoothstep(-aa, aa, -hd);\n        mm = mix(0.0, mm, fi);\n        mm = mix(mm, 1.0, fo);\n        \n        vec3 col = mix(from, to, mm);\n        vec2 ahn = abs(hn);\n        return col;\n    }\n\n\n    vec3 postProcess(vec3 col, vec2 q) {\n        col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n        col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n        col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n        col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n        return col;\n    }\n\n\n    void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        vec2 uv = fragCoord/iResolution.xy;\n        vec2 p = -1. + 2. * uv;\n        p.x *= iResolution.x/iResolution.y;\n        float aa = 2.0/iResolution.y;\n\n        float transition = smoothstep(0.1, 0.9, sin(iTime * .5) * 0.5 + 0.5);\n        \n        vec4 from = texture(firstTexture, uv);\n        vec4 to = texture(secondTexture, uv);\n\n        vec3 color = hexTransition(p, aa, from.rgb, to.rgb, transition);\n        \n        color = postProcess(color,uv);\n        ".concat(createDebugGLSLCode(0, 0, "transition"), "\n        fragColor = vec4(color, 1.0);\n    }\n\n\n    "), debugMode);
};
//# sourceMappingURL=FragmentShader.js.map